package main

// A simple counter program that uses a fan in fan out pattern

import (
	"fmt"
	"sync"
	"time"
)

// Fan Out function
func counter(id int, sleeptime time.Duration) chan []int {
	c := make(chan []int)
	go func() {
		defer close(c)
		for i := 0; i <= 10; i++ {
			result := []int{id, i}
			c <- result
			time.Sleep(sleeptime * time.Millisecond)
		}
	}()
	return c
}

// Second fun out function, just to simulate that we do something with the data
// generated by the counter
func printer(in <-chan []int) <-chan string {
	out := make(chan string)

	go func() {
		for n := range in {
			out <- fmt.Sprintf("Counter %d is at %d", n[0], n[1])
		}
	}()

	return out
}

// Fan In function
func merge(in ...<-chan string) <-chan string {
	var wg sync.WaitGroup
	out := make(chan string)

	output := func(c <-chan string) {
		for n := range c {
			out <- n
		}
		wg.Done()
	}

	wg.Add(len(in))
	// We use for loop with seperate function and not creating a
	// gorutine function here (go func(){}()) because we have multiple channels,
	// so we have to make output to the channel a diffrent function so that
	// we can use wait group and just launch gorutines in a for loop that takes
	// length of total channels as value.
	for _, c := range in {
		go output(c)
	}
	// Make wg.Wait() a gorutine so that we can instantly return
	// merge channel to the main function
	go func() {
		wg.Wait()
	}()

	return out
}

func main() {
	fmt.Println("Start fan out")

	var printers []<-chan string
	for i := 0; i <= 5; i++ {
		printers = append(printers, printer(counter(i, 500)))
	}

	out := merge(printers...)
	go func() {
		for n := range out {
			fmt.Println(n)
		}
	}()

	fmt.Scanln()
}
